name: Deploy to Development

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  NODE_VERSION: '20'
  TERRAFORM_VERSION: '1.6.0'
  ENVIRONMENT: dev

jobs:
  # Pre-deployment validation
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.validation.outputs.should_deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check deployment conditions
        id: validation
        run: |
          # Check if this is a forced deployment
          if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Forced deployment requested"
            exit 0
          fi
          
          # Check if CI passed for latest commit
          COMMIT_SHA="${{ github.sha }}"
          
          # For automatic deployment, we proceed
          echo "should_deploy=true" >> $GITHUB_OUTPUT

  # Infrastructure Deployment
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    if: needs.pre-deployment-checks.outputs.should_deploy == 'true'
    outputs:
      terraform_outputs: ${{ steps.terraform_output.outputs.terraform_outputs }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}
          terraform_wrapper: false

      - name: Terraform Init
        run: terraform init
        working-directory: infra/environments/dev

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        working-directory: infra/environments/dev
        env:
          TF_VAR_environment: ${{ env.ENVIRONMENT }}
          TF_VAR_region: ${{ env.AWS_REGION }}

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
        working-directory: infra/environments/dev

      - name: Get Terraform Outputs
        id: terraform_output
        run: |
          OUTPUTS=$(terraform output -json)
          echo "terraform_outputs=${OUTPUTS}" >> $GITHUB_OUTPUT
        working-directory: infra/environments/dev

      - name: Store infrastructure state
        uses: actions/upload-artifact@v4
        with:
          name: terraform-state-dev
          path: infra/environments/dev/terraform.tfstate
          retention-days: 30

  # Database Migration
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefix backend

      - name: Get database connection string
        id: db_connection
        run: |
          DB_HOST=$(echo '${{ needs.deploy-infrastructure.outputs.terraform_outputs }}' | jq -r '.rds_endpoint.value')
          DB_NAME=$(echo '${{ needs.deploy-infrastructure.outputs.terraform_outputs }}' | jq -r '.database_name.value')
          
          # Get database credentials from AWS Secrets Manager
          DB_SECRET=$(aws secretsmanager get-secret-value --secret-id "clinical-trial-db-${ENVIRONMENT}" --query SecretString --output text)
          DB_USER=$(echo $DB_SECRET | jq -r '.username')
          DB_PASSWORD=$(echo $DB_SECRET | jq -r '.password')
          
          echo "DATABASE_URL=postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/${DB_NAME}" >> $GITHUB_ENV

      - name: Run database migrations
        run: npm run migrate:up --prefix backend
        env:
          NODE_ENV: development

      - name: Seed development data
        run: npm run seed:dev --prefix backend
        env:
          NODE_ENV: development

  # Backend Deployment
  deploy-backend:
    name: Deploy Backend Lambda Functions
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, database-migration]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefix backend

      - name: Build Lambda functions
        run: npm run build --prefix backend

      - name: Package Lambda functions
        run: npm run package --prefix backend

      - name: Deploy Lambda functions
        run: |
          # Get Lambda function names from Terraform outputs
          TERRAFORM_OUTPUTS='${{ needs.deploy-infrastructure.outputs.terraform_outputs }}'
          
          # Deploy each Lambda function
          for lambda_zip in backend/dist/*.zip; do
            function_name=$(basename "$lambda_zip" .zip)
            terraform_key="${function_name}_function_name"
            
            aws_function_name=$(echo "$TERRAFORM_OUTPUTS" | jq -r --arg key "$terraform_key" '.[$key].value // empty')
            
            if [[ -n "$aws_function_name" ]]; then
              echo "Deploying $function_name to $aws_function_name"
              aws lambda update-function-code \
                --function-name "$aws_function_name" \
                --zip-file "fileb://$lambda_zip"
              
              # Wait for update to complete
              aws lambda wait function-updated \
                --function-name "$aws_function_name"
              
              # Update function configuration if needed
              aws lambda update-function-configuration \
                --function-name "$aws_function_name" \
                --environment Variables="{NODE_ENV=development,ENVIRONMENT=dev}" \
                --timeout 30
            else
              echo "Warning: No Terraform output found for $function_name"
            fi
          done

      - name: Update Lambda aliases
        run: |
          TERRAFORM_OUTPUTS='${{ needs.deploy-infrastructure.outputs.terraform_outputs }}'
          
          # Update LATEST alias for all functions
          for lambda_zip in backend/dist/*.zip; do
            function_name=$(basename "$lambda_zip" .zip)
            terraform_key="${function_name}_function_name"
            
            aws_function_name=$(echo "$TERRAFORM_OUTPUTS" | jq -r --arg key "$terraform_key" '.[$key].value // empty')
            
            if [[ -n "$aws_function_name" ]]; then
              # Get the latest version
              LATEST_VERSION=$(aws lambda publish-version --function-name "$aws_function_name" --query 'Version' --output text)
              
              # Update or create DEV alias
              aws lambda update-alias \
                --function-name "$aws_function_name" \
                --name "DEV" \
                --function-version "$LATEST_VERSION" || \
              aws lambda create-alias \
                --function-name "$aws_function_name" \
                --name "DEV" \
                --function-version "$LATEST_VERSION"
            fi
          done

  # Frontend Deployment
  deploy-frontend:
    name: Deploy Frontend Application
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-backend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_DEV }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefix frontend

      - name: Configure environment variables
        run: |
          TERRAFORM_OUTPUTS='${{ needs.deploy-infrastructure.outputs.terraform_outputs }}'
          
          # Extract values from Terraform outputs
          API_GATEWAY_URL=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.api_gateway_url.value')
          COGNITO_USER_POOL_ID=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.cognito_user_pool_id.value')
          COGNITO_CLIENT_ID=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.cognito_client_id.value')
          S3_BUCKET=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.s3_bucket_name.value')
          CLOUDFRONT_DOMAIN=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.cloudfront_domain.value')
          
          # Create environment file
          cat > frontend/.env.production << EOF
          NEXT_PUBLIC_API_URL=$API_GATEWAY_URL
          NEXT_PUBLIC_COGNITO_USER_POOL_ID=$COGNITO_USER_POOL_ID
          NEXT_PUBLIC_COGNITO_CLIENT_ID=$COGNITO_CLIENT_ID
          NEXT_PUBLIC_S3_BUCKET=$S3_BUCKET
          NEXT_PUBLIC_CLOUDFRONT_DOMAIN=$CLOUDFRONT_DOMAIN
          NEXT_PUBLIC_ENVIRONMENT=development
          NEXT_PUBLIC_APP_URL=https://$CLOUDFRONT_DOMAIN
          EOF

      - name: Build Next.js application
        run: npm run build --prefix frontend
        env:
          NODE_ENV: production

      - name: Deploy to S3
        run: |
          TERRAFORM_OUTPUTS='${{ needs.deploy-infrastructure.outputs.terraform_outputs }}'
          S3_BUCKET=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.s3_bucket_name.value')
          
          # Sync build files to S3
          aws s3 sync frontend/out/ s3://$S3_BUCKET/ --delete --cache-control "public, max-age=31536000, immutable" --exclude "*.html"
          aws s3 sync frontend/out/ s3://$S3_BUCKET/ --delete --cache-control "public, max-age=0, must-revalidate" --exclude "*" --include "*.html"

      - name: Invalidate CloudFront cache
        run: |
          TERRAFORM_OUTPUTS='${{ needs.deploy-infrastructure.outputs.terraform_outputs }}'
          DISTRIBUTION_ID=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.cloudfront_distribution_id.value')
          
          aws cloudfront create-invalidation \
            --distribution-id $DISTRIBUTION_ID \
            --paths "/*"

  # Post-deployment Tests
  post-deployment-tests:
    name: Post-deployment Health Checks
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-backend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefix tests

      - name: Wait for deployment to propagate
        run: sleep 60

      - name: Run health checks
        run: npm run test:health --prefix tests
        env:
          TEST_ENVIRONMENT: dev
          API_BASE_URL: ${{ needs.deploy-infrastructure.outputs.terraform_outputs.api_gateway_url.value }}
          APP_URL: https://${{ needs.deploy-infrastructure.outputs.terraform_outputs.cloudfront_domain.value }}

      - name: Run smoke tests
        run: npm run test:smoke --prefix tests
        env:
          TEST_ENVIRONMENT: dev

      - name: Performance regression test
        run: npm run test:performance --prefix tests
        env:
          TEST_ENVIRONMENT: dev

  # Security Validation
  security-validation:
    name: Post-deployment Security Validation
    runs-on: ubuntu-latest
    needs: [deploy-frontend]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: OWASP ZAP Baseline Scan
        uses: zaproxy/action-baseline@v0.10.0
        with:
          target: https://${{ needs.deploy-infrastructure.outputs.terraform_outputs.cloudfront_domain.value }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a'

      - name: SSL/TLS Security Test
        run: |
          DOMAIN="${{ needs.deploy-infrastructure.outputs.terraform_outputs.cloudfront_domain.value }}"
          
          # Test SSL configuration
          echo | openssl s_client -servername $DOMAIN -connect $DOMAIN:443 2>/dev/null | openssl x509 -noout -dates
          
          # Check for security headers
          curl -I https://$DOMAIN | grep -E "(Strict-Transport-Security|Content-Security-Policy|X-Frame-Options|X-Content-Type-Options)"

  # Deployment Success Notification
  deployment-success:
    name: Deployment Success Notification
    runs-on: ubuntu-latest
    needs: [post-deployment-tests, security-validation]
    if: always() && needs.post-deployment-tests.result == 'success' && needs.security-validation.result == 'success'
    steps:
      - name: Get deployment info
        id: deployment_info
        run: |
          TERRAFORM_OUTPUTS='${{ needs.deploy-infrastructure.outputs.terraform_outputs }}'
          APP_URL=https://$(echo "$TERRAFORM_OUTPUTS" | jq -r '.cloudfront_domain.value')
          API_URL=$(echo "$TERRAFORM_OUTPUTS" | jq -r '.api_gateway_url.value')
          
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Development Deployment Successful âœ…
          
          ## Deployment Details
          - **Environment**: Development
          - **Commit**: ${{ github.sha }}
          - **Deployed by**: ${{ github.actor }}
          - **Deployment time**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## Application URLs
          - **Frontend**: ${{ steps.deployment_info.outputs.app_url }}
          - **API**: ${{ steps.deployment_info.outputs.api_url }}
          
          ## Validation Results
          - âœ… Infrastructure deployed successfully
          - âœ… Database migrations completed
          - âœ… Backend Lambda functions deployed
          - âœ… Frontend application deployed
          - âœ… Health checks passed
          - âœ… Security validation passed
          
          ## Next Steps
          - Test the application at: ${{ steps.deployment_info.outputs.app_url }}
          - Monitor CloudWatch logs for any issues
          - Proceed with staging deployment when ready
          EOF

      - name: Notify Slack (if configured)
        if: env.SLACK_WEBHOOK_URL != ''
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "ðŸš€ Development deployment successful",
              "attachments": [
                {
                  "color": "good",
                  "fields": [
                    {"title": "Environment", "value": "Development", "short": true},
                    {"title": "Commit", "value": "${{ github.sha }}", "short": true},
                    {"title": "App URL", "value": "${{ steps.deployment_info.outputs.app_url }}", "short": false}
                  ]
                }
              ]
            }' \
            ${{ secrets.SLACK_WEBHOOK_URL }}

  # Cleanup on Failure
  cleanup-on-failure:
    name: Cleanup Failed Deployment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, database-migration, deploy-backend, deploy-frontend, post-deployment-tests]
    if: always() && (needs.deploy-infrastructure.result == 'failure' || needs.database-migration.result == 'failure' || needs.deploy-backend.result == 'failure' || needs.deploy-frontend.result == 'failure' || needs.post-deployment-tests.result == 'failure')
    steps:
      - name: Rollback deployment
        run: |
          echo "Deployment failed. Manual intervention required."
          echo "Check the following:"
          echo "1. Infrastructure deployment status"
          echo "2. Database migration logs"
          echo "3. Lambda function deployment logs"
          echo "4. Frontend deployment logs"
          echo "5. Post-deployment test results"
          
          # Create failure summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Development Deployment Failed âŒ
          
          ## Failed Components
          - Infrastructure: ${{ needs.deploy-infrastructure.result }}
          - Database: ${{ needs.database-migration.result }}
          - Backend: ${{ needs.deploy-backend.result }}
          - Frontend: ${{ needs.deploy-frontend.result }}
          - Tests: ${{ needs.post-deployment-tests.result }}
          
          ## Manual Intervention Required
          Please check the job logs and resolve issues before retry.
          EOF